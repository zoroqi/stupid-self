# 152. 乘积最大子数组

```
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-product-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 愚笨的思考

大小判断 负数 \< 0 \< 正数, 数学乘法基本原则, 负数\*负数=正数, 任何数字和0相乘等于0

循环进行乘积操作

1. 记录第一次出现负数的乘积结果
2. 出现第二次负数将第一次乘积结果修改为1
3. 出现零或未出现负数, 将最后结果除以前一次负数的乘积, 比较大小. 计算两个负数之间的乘积
4. 出现零则整体状态恢复为基本状态继续计算, 回归第一步


### 失败

通过记录上一次负数, 来记录负数和负数之间的乘积, 但这种方式无法记录中间出现过多少次1, 会导致\[-1,1\]/\[-1,1,0\] 这种无法发现

第一次修正, 添加一个`interval`记录负数之间的间隔, 来解决是`1`的存在

### 失败二

发现出现奇数个负数, 没有考虑到. 奇数个负数的结合只存在左右两种结合方式

第二次修正, 算法逻辑不变, 将数组进行正反向两次遍历, 可以会得到新的结果.

## 进一步思考
1. 在不包含0的情况下, 实际上是针对数组进行一次从左进行偶数个负数的乘法, 从右侧进行一次包含偶数个负数的乘法. 
2. 实际上是针对上一个算记性一定优化.

## 网友算法

网友:rebelHero

评论实现是错误的, 需要进行修正, imin和imax初始值是nums\[0\]元素, 遍历从1开始.

算法流程:
1. 存储两个临时变量, 最小(imin)和最大(imax)
2. 在`num<0`下, 交换最小和最大
3. 计算乘积并进行比较和当前元素比较, 修正最下和最大值
4. 比较获得最终结果

注意点:
1. 保证在出现0的情况, 需要对状态清0
2. 多个负数情况需要进行左右两种组合方式

分析:
1. 0出现, 通过比较可以将0作为最大值的备选项, 通过比较可以将状态清0
2. imax和imin始终保持一个元素存储左结合一个存储右结合
3. 在出现负数情况下交换imax和imin.
    1. 奇数次负数
        1. imin存储左结合的连续乘积
        2. imax存储右结合的连续乘积(不包含第一个奇数)
    2. 偶数次负数
        1. imax存储左结合的连续乘积
        2. imin存储右结合的连续乘积(不包含第一个奇数)
4. 第一个负数出现后有元素, 通过`max(imax*n,n)`方式舍弃了第一个负数, imax保留了负数后第一个元素值. 之后的计算就是在进行左右结合的交换

例:

| loop | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 数组元素 | 2 | 2 | 3  | 0 | 2 | -1 | 4  | -2 | 8   | -3   | -2   |
| imin    | 2 | 2 | 3  | 0 | 0 | -2 | -8 | -8 | -64 | -384 | -384 |
| imax    | 2 | 4 | 12 | 0 | 2 |  0 | 4  | 16 | 128 | 192  | 768  |

| loop | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| 数组元素 | -2 | -3 | -3 | -2 | -3  | -4  |
| imin    | -2 | -3 | -18 | -18 | -108 | -216 |
| imax    | -2 | 6 | 9 | 36 | 54 | 432 |




## 总结

开始考虑问题不全面, 没考虑到左右结合的情况, 然后简单执行两次就完成了. 参考网友答案, 发现那个方法出奇的秒, 靠着几行代码实现功能. 自始至终没理解为啥这个题和动规有关系.
