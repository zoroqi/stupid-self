# 330. 按要求补齐数组

```
给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

示例 1:

输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
示例 2:

输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
示例 3:

输入: nums = [1,2,2], n = 5
输出: 0


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/patching-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 愚笨的思考

最开始想到的方案比较简单, 就是穷举所有可能后获得每一个差值, 对所有差值进行计算, 发现有问题且并不知道如何找到数字, 最终要的是我还要穷举可能性. 之后开始想办法先暴力穷举, 发现haskell是真的暴力. 

用的haskell写的辅助代码. 简单暴力至极. 尤其是`.`和`$`的使用. 发现进行辅助验证和测试对思考很有帮助
```haskell
-- 生成所有子集, 包括空集
subsets :: [a] -> [[a]]
subsets []  = [[]]
subsets (x:xs) = subsets xs ++ map (x:) (subsets xs)

-- 去重和排序的依赖
import Data.List

-- 返回所有已知结果
sort .nub  .tail .map sum . subsets $[1,3,11]

-- 返回新加元素后 小于目标 20 的结果
filter (<=20) .sort .nub  .tail .map sum . subsets $[1,3,11,2,4]

-- 统计数量. 人眼数20个数字容易眼花
length .filter (<=20) .sort .nub  .tail .map sum . subsets $[1,3,11,2,4]
```

### 方案一

测试用的数据是`[1,3,7]` n是20. 感觉至少需要2个数字(没理由), 然后一个一个进行手动尝试, 左后测试结果是添加2和7最后成功了. 然后尝试把n改成40, 第一反应和目标值差20个数字\(21\~40\), 感觉也应该需要2个数字, 但测试发现只在需要1个数字就是20.  进一步思考, 这个题可以转换为一下描述:

如何用最少的数字实现n/2数组范围内的连续, 剩下部分就可以直接由一个数字搞定了. 

以`1,3,7->20`就要满足第一步是如何找到`1~10`的连续. 基于这个思路发现代码很难实现, 逻辑判断太复杂了, 很难把大脑中的判断转换成代码. 

### 突然的发现

集合中的如何用最少的数字来组合出1\~n的所有数字, 其实就是二进制表示, 只需要保留1对应的数字就好了. `1,2,4,8,16,32`
```
1,2 -> 3
1,2,4 -> 7
1,2,4,8 -> 15
```
### 方案二

基于以上的结论, 我可以将填充逻辑转成计算当前连续的最大范围

新的最大范\(max\)围计算有两种情况

1. 当`max>=(nums[i]-1)`, 新的范围就是`max+nums[i]` 
2. 当`max<(nums[i]-1)`, 新的范围就是`max*2+1`, 这部操作等于加入一个数字, 继续验证`max>=(nums[i]-1)`.

当nums遍历完后, max依旧不满足n, 就反复执行步骤2

#### 测试不完全逻辑

1. `[.a,b..]` 当`n<b`的情况导致计算超出