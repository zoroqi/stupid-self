---
id: 20221012220103_621bd0ba39fc48b0
date: "2022-10-12"
tc:
- leetcode
- algorithm
aliases:
- 481. 神奇字符串
---

# 481. 神奇字符串

神奇字符串 s 仅由 '1' 和 '2' 组成，并需要遵守下面的规则：

神奇字符串 s 的神奇之处在于，串联字符串中 '1' 和 '2' 的连续出现次数可以生成该字符串。
s 的前几个元素是 s = "1221121221221121122……" 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 "1 22 11 2 1 22 1 22 11 2 11 22 ......" 。每组中 1 或者 2 的出现次数分别是 "1 2 2 1 1 2 1 2 2 1 2 2 ......" 。上面的出现次数正是 s 自身。

给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。

```

示例 1：

输入：n = 6
输出：3
解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。
示例 2：

输入：n = 1
输出：1

```

提示：

`1 <= n <= 10^5`

## 愚笨的思考

看到题的第一反应, 这个数字串应该是一组数字的周期循环, 所以只要找到循环的基数应该就可以了. 问题变成了如何找到这个周期数列.

## 寻找周期

```
1221121221221121122……
12 2 112 12 2 12 2
12   2 1 12   12
12     2  1   1
12        2
12
11
2
```

可以从 2 生成这个数列, 为了方便从 [1,2] 开始生成, 使用 golang 生成响应的数列.尝试生成后感觉没啥规律, 至少 382 位内没有产生周期, 那说明周期可能不再这个范围内或者就没有周期. 简单统计可以得到一下数列

```
[1 2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 2 1 2 1 1 2 1 2 2 1 1 2 1 1 2 1 2 2 1 2 2 1 1 2 1 2 2 1 2 1 1 2 1 1 2 2 1 2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 1 2 2 1 2 1 1 2 2 1 2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 2 1 2 1 1 2 1 2 2 1 2 2 1 1]

[1 1 1 2 3 3 4 4 4 5 5 5 6 7 7 8 9 9 9 10 10 11 12 12 13 13 13 14 15 15 16 17 17 18 18 18 19 19 19 20 21 21 22 22 22 23 23 24 25 25 26 27 27 27 28 28 28 29 30 30 31 31 31 32 32 32 33 34 34 35 36 36 37 37 37 38 38 39 40 40 40 41 41 41 42 43 43 44 44 44 45 45 45 46 47 47 48 49 49 49 50 50 51 52 52 53 53 53 54 54 54 55 56]
```

尝试到 500 位也没有出现规律, 可能这个寻找周期的方案是不行的, 需要总结别的规律. 现在暴力方案已经实现了, 生成数列直接计算就好了.

### 简单的数列生成

第一版生成方案是直接从 `[1, 2]` 一层一层向展开的, 数列增长速度是 50%, 这要增长到我目标值, 需要的循环次数太多了. 有没有不展开直接生成的方案, 这种即使采用暴力效果也会比展开效果好.

思考过程中, 想到一个问题, 当前数列可以生成下一个数列, 我是不是可以通过 3 个或 4 个数字直接推算出下一个数字, 而不需要一层一层的生成下一个数列. 其中有一些必定的子结构 `[2, 2]` 之后一定是 1, `[1, 1]` 之后一定是 2. 可能存在一种只需要知道有限数据生成下一个结构.

简单统计看了看, 发现没戏, 存在 221 之后情况是不确定的, 1221 之后也是不确定的, 那就没有办法简单生成了.

### 用队列生成数列

每一层数列前 x 位都是一样, 所以可以使用队列进行生成.
1. 入队元素第一个元素, 从 "2" 开始
2. 出队元素
    1. 根据前一个元素生成响应的新元素
    2. 将未处理的元素入队

这样可以无限生成下去, 测试没有问题, 为了方便需要从 [1, 2, 2] 之后进行处理比较简单. 因为 第二个数字的出队的时候前一个数字是 1 , 而简便写法没法实现很困难, 所以从第三个数字入队比较轻松.

golang 一次通过, 但感觉代码好长, python 的好像只有 10 行, 我写了 40 行.

## haskell 的思路

我期望用这种方式实现 `fibs = 1 : 1 : zipWith (+) fibs (tail fibs)` 数列的生成. 这行代码依旧深深的让我震撼. 来源 509 题中从网上找到的代码. 在看到这个代码之前我无法想象代码可以这么写, 这种代码写起来才真的有意思啊.

P.S. haskell 函数声明可以有形参名称吗? 函数声明参数一多就真的看不懂了.

实现一个逐层生成的, 看起来太费劲了, 而且性能很不好, 生成 25 层时间就无法忍受, 进入分钟级才有结果. 太多递归引起的.

```hs
sieve (p:xs) = p : sieve [x| x <- xs , x `mod` p /=0 ]
primes = sieve [2..]
```

我找到了一个写法, 这里需要实现 y 在 [2, 1] 交互出现就可以了, 但这个交互出现不知道咋实现; 习惯了命令式的代码, 第一想法就是来一个变量和分支判断交替 y 值, 问题是 haskell 不能这么做. 最后一个元素一定是和前一次相反的结果.
```hs
nums = [[2]]++[expand y x | x <- concat(nums)]
-- 这么做可以得到对应的数字
take 10 ([1,2] ++ (concat nums))
```

上班路上思考有没有办法, 突然发现我也可以用 zipWith, 没必要一定要用集合生成方式. 我只需要有一个 [2,1,2,1..] 的数列和目标数列逐一 expand 就好了.

最后成功将代码压缩到了 9 行, 不算声明部分 6 行, 核心代码只有 1 行, 这 1 行我写了足足 2 个小时. 但是代码理解成本很高. 我过一段时间可能就忘了这段代码是什么意思了, 但理解难度比递归的低很多.

而且性能优化了千倍, 测试 22029 这个参数, planA \(实际输入参数是 23, 23 转换成数列长度是 22029\)的方案需要 8s 时间, 而 planB 的时间是毫秒级别.

吐槽下 `. $` 看起来太费劲了, 多写括号吧.

## 存在周期吗?

我很好奇这个数列存在周期循环吗? 这个要如何证明. 代码写完后, 感觉是没有周期循环的.

假设存在周期, 则数列结构是这样子的 [1,2,2,1,1,2,1...., 1,2,2,1,1,2,1....,1,2,2,1,1,2,1....]. 而中间某个周期的数列是由前一个周期内数字生成的, 或者前一个周期生完成本周期的输出并切只能余出 [1, 2] 两个数字. 遍历数列的速度永远无跟上数列的扩充速度.

P.S. 没有任何目的做数学题和算法题真的是一件快乐的事情.

正式证明不知道咋证明.
