---
id: 20221012213947_a31294bb45304309
date: "2022-10-12"
tc:
- leetcode
- algorithm
---

# 448 找到所有数组中消失的数字

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。


```
示例 1：

输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
示例 2：

输入：nums = [1,1]
输出：[2]
```


提示：
```
n == nums.length
1 <= n <= 10^5
1 <= nums[i] <= n
```
进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

## 愚笨的思考

### 计划A

定义一个 (Int, Bool) 的字典或Set, 将数组写入其中, value 是 true. 对 1\~n 元素用 filter 过滤.

问题是 haskell 咋实现. 看需要使用 Data.Map 包. 最后使用的是 `Data.HashSet`, 来源`unordered-containers`包

导入包的时候可以加上`qualified`关键字防止污染命名空间. haskell 实现我没想到会这么快, golang 构建字典还需要我遍历一遍, 这个很快现成的方法, 连循环都不用写

### 计划B

对原始传入数组进行排序, 然后采用类似归并的思路进行处理. 当两个集合数据无法正确对应的时候就调整到对应调整

这里的时间复杂度 `O(nlogn)` 和计划 A 具体是相似的, 取决于 Set 实现方案, 使用 Hash 表可能小于 `O(nlogn)`, 使用 Tree 的时间复杂度就一致了.

```
1,2,3,4,5,6,7,8,9,10
1,2,3,  5,  7,8,9,10 -> [4,6]
1,    4,5,6,7,8,9,10 -> [2]
1,2,3,7,8,9,9,9,9,10 -> [4,5,6]
1,2,2,2,2,7,8,9,9,10 -> [3,4,5,6]
```

问题是 haskell 我有不知道怎么实现了. golang 我才用了一个很复杂的偏移量计算的方式. 大致流程是
1. 排序
2. 合并重复内容
3. 小于目标序列的值进行填充到目标值
4. 大于目标序列的值也进行填充, 填充到序列值
5. 最后判断目标值是否遍历完, 没有填充剩下的值

我用 golang 实现的时候是把 2,3,4 三个步骤合并了, 最后代码显得很复杂

我用 haskell 可能就不能这么实现了, 我需要合并后直接进行比较输出.

haskell 可能是我第一次自己写代码自己不知道为啥对了的代码. 主要是我对递归调用真的没有信心.

这里的三个逻辑
1. 相等, 指针同时后移
2. x > y, 需要填补 y 到结果集; x 的指针不移动, y 的指针后移, 直到两边相等
    * 因为输入限制, `1 <= nums[i] <= n` 不会出现 `(x:xs) []` 的匹配情况.
3. x < y, 根据算法不会出现这种情况
    * 因为输入限制, `1 <= nums[i] <= n`, 当出现缺失值是因为`x > y`的场景出现了, 然后移动指针到相同. 再次出现就又是 `x > y`

### 计划C

看了别人的答案, 发现好像我的方案并不好, 看来还有别的方案. 继续思考咋做吧. 但看简单实现可能 haskell 我更无法实现了.

目标集合是确定的, 只要我通过交换找到数字就可以了, 出现重复的数字进行多次记录, 通过对数组进行遍历, 将数据写入到对应位置, 写入的时候写入负数, 逐一替换后; 最后在进行一次遍历, 将大于0的索引就是没有使用的数据.

1. 遍历数组
2. 当`nums[i]>0`那就将 `nums[nums[i]-1]` 中的元素设置为 `-nums[i]`; `nums[nums[i]-1]`中的值继续替换知道 `nums[i] <= 0`
3. `nums[nums[i]-1] <= 0` 那就将`nums[i]` 设置为0
4. 再次遍历数组, 所有 `>=0` 的索引就是不存在的值

看网友的答案找到一个更简单的方案

1. 遍历数组
2. 对`nums[nums[i]-1]`中的数据`+=n`
3. 小于n的数据就是存在的值

根据我的 haskell 能力我的计划C可能没法实现, 看看网友的方案是不是可行. 整体有点困难


