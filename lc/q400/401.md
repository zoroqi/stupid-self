---
id: 20221012214712_f56b3cc4775e40e2
date: "2022-10-12"
tc:
- leetcode
- algorithm
---

# 401. 二进制手表


二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

* 例如，下面的二进制手表读取 `"3:25"` 。


```
hour: 8,4,*2*,*1*
minuts: 32,*16*,*8*,4,2,*1*
```

给你一个整数 `turnedOn` ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 **按任意顺序** 返回答案。

小时不会以零开头：

* 例如，`"01:00"` 是无效的时间，正确的写法应该是 `"1:00"` 。

分钟必须由两位数组成，可能会以零开头：

* 例如，`"10:2"` 是无效的时间，正确的写法应该是 `"10:02"` 。

示例 1：

输入：turnedOn = 1
输出：\["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"\]

示例 2：

输入：turnedOn = 9
输出：\[\]

提示：

* `0 <= turnedOn <= 10`

## 愚笨的思考

先吐槽一下, 事真多还限制输出格式, 需要补充`"0"`, 感觉测试程序就是用 `set` 结构存储数据.

这个题最快的方式就是写枚举直接返回, 因为每一个数字答案是确定的, 这么做是最快的.
```
switch (turnedOn) {
    case 0:
        return []
    case 1:
        return ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
    ....
}
```

暴力答案: 这个问题就是对`[0..9]`集合的子集, 所有结果过滤输出. 总共1024中可能, 满足要求的只是一部分.`[0..3]` 对应小时的`[1,2,4,8]`, `[4..9]`对应分钟的`[1,2,4,8,16,32]`.

方案一:

就像暴力答案中一样
1. 生成所有子集, 过滤出长度`turnedOn`的子集
2. 以 4 分界, 分别计算小时和分钟
3. 过滤掉错误时间
4. format 输出

方案二:

直接对`[0..1023]`进行全量计算, 然后过滤也可以. 这样就变成了纯粹的验证逻辑了.

1. 二进制数字是否包含`turnedOn`个数字"1"
2. 对前四位求十进制
3. 对后六位求十进制
4. 过滤掉错误时间
5. format 输出

感觉可以通过数字范围可以进行一定的过滤, 来减少遍历数量, 但感觉在这问题上并不会有什么好处
