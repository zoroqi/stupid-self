# 400. 第 N 位数字

给你一个整数 n ，请你在无限的整数序列[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第n 位上的数字。

```
示例 1：

输入：n = 3
输出：3
示例 2：

输入：n = 11
输出：0
解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。
```

提示：

1 <= n <= 2^31 - 1

第 n 位上的数字是按计数单位（digit）从前往后数的第 n 个数，参见 示例 2 。

## 愚笨的思考

第一反应应该有类似数学计算公式的方案, 但那个有点难, 优先实现暴力方案.

### 暴力方案 计划A

1. 处理数字转换成新的数组 `123 -> [1,2,3]`
2. 将新拆分的数组合并
3. 直到数组长度打到目标数量

haskell 实现还是比较简单的, 拆分, 翻转, 合并, 获取前 n 项, 获取最后一个元素.

haskell 知道几个小技巧, ghci 中可以通过分号搞定换行的问题.

### 计算方案 计划B

这个问题读题让我想到一个"统计1\~n中有多少个0"的问题. 然后答案就是可以通过计算得到. 这个应该也可以.

基于计划A可以获得对应拆列后的新集合, 对数组进行观察可以这样进行分组 `[(0..9), (1,0,1,1..9,9),(1,0,0,1,0,1..9,9,9)...]`.

每一组的数量 `[9,180,2700,36000...] -> [1*9,2*90,3*900,4*9000]` 所以在知道 n 以后可以快速确认数字在几位数的范围内. 通过减去指定范围可以获得对应的索引位置.

1. 计算 n 在几位数 c
2. r = n - 前边的数位和
3. `r mod (c*10^c) == 0` 结果就是 `r div (c*10^c)`
4. 循环计算 `m = r mod (c*10^(c-i))` 直到 `(m == 0)` 就是结果

发现不对, 从新思考 计划B

1. 计算 n 在几位数 c
2. "n - 前边的数位和" 可以知道对应的数据起点 m
3. 置顶范围内所有数字都是 c位数, 计算 `num = (m-1)/c` 可以得到对应的数字是多少.
4. 计算位数 `index = (m-1)%c`
5. 返回对应 num 第 index 位置的数字, 从0开始, 从左至右计数

为什么要进行"`m-1`"? m 代表的是当前数据段中的位置, `[100..]` 中对应的数量, 计数是从 1 开始的, 计算索引需要从 0 开始, 自然要减一. 加上对应偏移量, 是方便知道对应数字.

所有思考过程都是马后炮.

## haskell 遇到的一些问题

1. 匹配中不能使用比较, 必须用 guard 或 if 语句 ?
2. golang 实现的时候隐含了多返回值, haskell 无法实现, 需要考虑新的方式进行计算?
    1. 分成多个步骤计算
3. 不知道为啥 take 函数的参数类型要是 Int 而不是 Word. 本身 take 并不支持负数为啥不用无符号整数呢? 看源码神奇的发现可以在匹配中使用 guard, 然后解决了第一个问题, 然后发现在一定情况下 guard 不是必须要有 otherwise 的. 因为 if 语句必须有对应的 else 分支.
    ```hs
    take n _ | n <= 0 =  []
    take _ []         =  []
    take n (x:xs)     =  x : take (n-1) xs
    ```
4. 实现简单暴力版还是很有好处的, 可以快速知道正确性. 可以快速验证内容的正确性, 只要简单版本是对的, 只需要比较两次结果就好了.
    ```hs
    test n = (map findNthDigitPlanB [1..n]) == (map findNthDigitPlanA [1..n])
    test 10  -- True
    test 100 -- True
    ```
