# 400. 第 N 位数字

给你一个整数 n ，请你在无限的整数序列[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第n 位上的数字。

```
示例 1：

输入：n = 3
输出：3
示例 2：

输入：n = 11
输出：0
解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。
```

提示：

1 <= n <= 2^31 - 1

第 n 位上的数字是按计数单位（digit）从前往后数的第 n 个数，参见 示例 2 。

## 愚笨的思考

第一反应应该有类似数学计算公式的方案, 但那个有点难, 优先实现暴力方案.

### 暴力方案 计划A

1. 处理数字转换成新的数组 `123 -> [1,2,3]`
2. 将新拆分的数组合并
3. 直到数组长度打到目标数量

haskell 实现还是比较简单的, 拆分, 翻转, 合并, 获取前 n 项, 获取最后一个元素.

haskell 知道几个小技巧, ghci 中可以通过分号搞定换行的问题.

### 计算方案 计划B

这个问题读题让我想到一个"统计1\~n中有多少个0"的问题. 然后答案就是可以通过计算得到. 这个应该也可以.

基于计划A可以获得对应拆列后的新集合, 对数组进行观察可以这样进行分组 `[(0..9), (1,0,1,1..9,9),(1,0,0,1,0,1..9,9,9)...]`.

每一组的数量 `[9,180,2700,36000...] -> [1*9,2*90,3*900,4*9000]` 所以在知道 n 以后可以快速确认数字在几位数的范围内. 通过减去指定范围可以获得对应的索引位置.

1. 计算 n 在几位数 c
2. r = n - 前边的数位和
3. `r mod (c*10^c) == 0` 结果就是 `r div (c*10^c)`
4. 循环计算 `m = r mod (c*10^(c-i))` 直到 `(m == 0)` 就是结果

发现不对, 从新思考 计划B

1. 计算 n 在几位数 c
2. "n - 前边的数位和" 可以知道对应的数据起点 m
3. 置顶范围内所有数字都是 c位数, 计算 `num = (m-1)/c` 可以得到对应的数字是多少.
4. 计算位数 `index = (m-1)%c`
5. 返回对应 num 第 index 位置的数字, 从0开始, 从左至右计数

