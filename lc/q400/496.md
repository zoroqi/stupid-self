# 496 下一个更大元素 I

nums1中数字x的 下一个更大元素 是指x在nums2 中对应位置 右侧 的 第一个 比x大的元素。

给你两个 没有重复元素 的数组nums1 和nums2 ，下标从 0 开始计数，其中nums1是nums2的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。

```
示例 1：

输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。

示例 2：

输入：nums1 = [2,4], nums2 = [1,2,3,4].
输出：[3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 2 ，nums2 = [1,2,3,4]。下一个更大元素是 3 。
- 4 ，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
```


提示：
```
1 <= nums1.length <= nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 104
nums1和nums2中所有整数 互不相同
nums1 中的所有整数同样出现在 nums2 中
```

进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/next-greater-element-i) 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 愚笨的思考

### 暴力方案 计划A

简单来说就是反复遍历, 因为条件限制**不会出现重复数字**, 切nums1是nums2的子集. 所以暴力实现就是对 nums2 进行遍历, 找到目标数字后在遍历之后的数字.

因为整个集合不太大才 1000 那最大时间复杂度也就是 O(1000^2).

实现流程就是
1. 遍历 nums1
2. nums[i] 在 nums2 中查找到对应元素nums[j], 返回 nums[j+1,]
3. nums[j+1,] 寻找大于 nums[i] 的数据并返回

在用 haskell 实现的时候我还是喜欢用括号, 使用 "$" 和 "." 太恐怖了.

### 优化方案 计划B

nums1 是 nums2 的子集, 所以我们可以先计算 `nums2 nums2` 的情况, 这个相对好计算. 使用队列结构进行遍历

1. 第一个元素入队
2. 查看队头元素和新元素比较
    1. 大于头元素出队并记录新元素, 直到出现小于为止
3. 新元素入队
4. 循环步骤2到最后一个元素
6. 遍历完后, 对队列中剩余元素进行出队并写入"-1"

这是可以实现一次性遍历生成一个新的集合, 这里可以同步生成一个 map, key: 元素, value: 下一个更大元素. 剩下就是遍历 nums1 从 map 中取出对应 value 就可以了.

**测试发现思路有问题, 这是一个失败的方案**

对头元素过大会将中间元素给合给并掉, 这样就没有意义了.

产生这个思路的原因. nums1 和 nums2 都不能调序, nums1 只是 nums2 的子集但顺序并不一致. 那我是不是可以生成一个 nums2 和 nums2 构成的结果, 然后从中过滤出目标子集就好了. 因为数据一致, 顺序也一致, 可能就在一次遍历中实现了. 但实现后进行测试发现不对.

但这个思路可能还是可以的, 相同集合生成的结果可能实现更简单.

### 优化方案 计划C

计划B 我最开始思考是用的栈, 但为了保持输出顺序被我调整成了队列, 简单找个列表试了下发现可以就队列了, 最后代码实现完发现不对了. 这个逻辑是对的, 但依旧需要一个map进行存储.

1. 第一个元素入栈
2. 查看栈顶元素和新元素进行比较
    1. 大于栈顶元素出栈并记录新元素, 直到出现小于为止
3. 入栈新元素
4. 遍历完后, 对栈中剩余元素进行出栈并记录"-1"

这样是可以正确得到数据. 我为啥会想到用栈呢? 至少我在写的时候并没有想清楚为啥会用栈.

断断续续刷了一些题, 然后写一个简单的栈越来越熟练了. 跑 lc 的测试我的优化好像没啥效果, 白优化了.

用 haskell 实现发现又不会了, 蛋疼啊. 我实现必须进行修改变量, 转成递归就不会了. 我要找一些 leetcode 的 haskell 版学习看看. 关注下 [clyring - Codeforces](https://codeforces.com/profile/clyring) 的代码.

成功用 haskell 实现, 看 golang 的实现, 涉及到了两个循环, 那在 haskell 就会有两个递归. 我实现的表面上是一个递归函数, 但实际靠着变量修改实现了第二个递归. 这是实现看着好烂啊, 最后的优化可以存储一个 Map 来提高检索速度, 暂时用遍历来实现吧.

