---
id: 20221012214104_2ce8bd15fe3f466d
date: "2022-10-12"
tc:
- leetcode
- algorithm
aliases:
- 461. 汉明距离
---

# 461. 汉明距离

两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

```
示例 1：

输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。

示例 2：
输入：x = 3, y = 1
输出：1

```
**提示：**
* `0 <=x, y <= 2^31 - 1`

## 愚笨的思考

### 计划A

很简单, 转成二进制逐位比较.

最大的问题是怎么转换成二进制数组, 我最开始以为有现成的库, 就像 python 的 `bin()` 函数, 找着了发现都是告诉我怎么实现, 问题是我不想实现这部分. 短时间没找到, 自己做了一个
1. 为了比较方便比较, 可以指定输出的二进制长度.
2. 我不需要按照从高到低的顺序输出, 只要位置是对的就可以了

我不想用递归, 改成使用元组列表进行保存来生成, 而没有使用递归实现.

[生成二进制的参考](https://itecnote.com/tecnote/r-how-to-implement-decimal-to-binary-conversion/)

还发现了一个神奇的 divMod 函数; 还发现没有更神奇的 modDiv 函数; 最神奇的是看了源码后我发现 div 和 mod 函数是 divMod 的包装, 而 divMod 我看不懂是咋实现的, 我实际上是不知道任何语言的除法的实现. 仔细想想其实是对的, 计算商和余数的时候, 就是一次性算出来的, 并不需要分两次进行计算.

```hs
n `div` d           =  q  where (q,_) = divMod n d
n `mod` d           =  r  where (_,r) = divMod n d
divMod n d  =  if signum r == negate (signum d) then (q-1, r+d) else qr
             where qr@(q,r) = quotRem n d
```
