---
id: 20221012220604_88a3376de9dc4b26
date: "2022-10-12"
tc:
- leetcode
- algorithm
aliases:
- 406. 根据身高重建队列
---

# 406. 根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki`  个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

**示例 1：**

**输入：**people = \[\[7,0\],\[4,4\],\[7,1\],\[5,0\],\[6,1\],\[5,2\]\]
**输出：**\[\[5,0\],\[7,0\],\[5,2\],\[6,1\],\[4,4\],\[7,1\]\]
**解释：**
```
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```
**示例 2：**

**输入：** people = \[\[6,0\],\[5,0\],\[4,0\],\[3,2\],\[2,2\],\[1,4\]\]
**输出：** \[\[4,0\],\[5,0\],\[2,2\],\[3,2\],\[1,4\],\[6,0\]\]

**提示：**

*   `1 <= people.length <= 2000`
*   `0 <= hi <= 106`
*   `0 <= ki < people.length`
*   题目数据确保队列可以被重建

## 愚笨的思考

### 最暴力的方案 计划A

最简单的方案就是生成全排列, 进行验证, 虽然慢但是可以实现. 步骤

1. 生成全排列
2. 逐一校验每一个排列
    1. 判断最后一个元素是否满足正确位置
    2. 满足向前验证都输第二个
    3. 不满足直接返回, 验证下一个排列

当然这个方案很简单, 但耗时会很长, 尤其是元素多了以后时间根本无法接受. 这个方案的时间复杂度是 `O(n!)` 太恐怖了, 7 个元素就要验证 5040 种情况.

haskell 实现的时候第一个问题就是递归咋写, 脑子经常绕不过来, 始终在思考循环语句.

### 换个思路 计划B

找个复杂点的例子
```
[(6,0),(5,0),(4,0),(3,2),(3,3),(2,2),(1,4)]
->
[(4,0),(5,0),(2,2),(3,2),(1,4),(3,3),(6,0)]
```

手动排序总结出一下结论
1. 同身高的是按照第二位进行排序的
2. 不同身高第二位相同, 按照身高进行排序

进行身高和第二位的联合排序, 然后确定位置.

1. 进行排序
2. 对最小身高处理, 将第二位理解为数组索引写入新的数组
3. 对次身高的同样处理, 索引位置已经占用顺序向后移动
4. 循环第三步骤

#### 发现不对

测试没有通过, 发现 `[6 1]` 不符要求,
```
[[4 4] [5 0] [5 2] [6 1] [7 0] [7 1]]

[[5 0] [6 1] [5 2] [7 0] [4 4] [7 1]]

正确答案
[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
```

根据结果来看`[6 1]`写入的索引还是 1 位置, 但 1 是根据未使用的位置重新计算.

这次成功了, 第一次golang在进行处理的时候, 选择了反复遍历数组计算新的索引, 耗时在20ms左右. 需要再优化看看.

#### 事后诸葛亮

虽然做出来的但并没有给自己一个可以接受的解释, 思考最后得出了对应的解释.

排序从低到高可以处理, 低身高更容易确定位置, 前边写入的都是比当前高的, 所以需要在写入后续的数据重新计算索引.

排序从高到低也可以处理, 身高是降序, 位置升序. 通过移动进行构建, 根据新构建的数组中大于自身进行索引计算. 但这种实现会更复杂, 效果也不快

#### 进行优化

长一点的例子
```
people:    [[2 4] [3 4] [9 0] [0 6] [7 1] [6 0] [7 3] [2 5] [1 1] [8 0]]
sort:      [[0 6] [1 1] [2 4] [2 5] [3 4] [6 0] [7 1] [7 3] [8 0] [9 0]]
result:    [[6 0] [1 1] [8 0] [7 1] [9 0] [2 4] [0 6] [2 5] [3 4] [7 3]]
第二种sort: [[9 0] [8 0] [7 1] [7 3] [6 0] [3 4] [2 4] [2 5] [1 1] [0 6]]
```

#### 真正的困难

haskell 咋实现, 涉及赋值和插入逻辑. 我坚定的认为不要有修改变量的操作.


