---
aliases:
- 896. 单调数列
- 896. monotonic array
tc:
- leetcode
- algorithm
leetcode:
  num: 896
  url: https://leetcode.cn/problems/monotonic-array/
  tags:
  - 数组
date: "2022-10-19"
id: 20221019201946_0251cc55ddd54df3
---

# 896. 单调数列

如果数组是单调递增或单调递减的，那么它是 单调 的。

如果对于所有 i <= j，nums[i] <= nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i <= j，nums[i]> = nums[j]，那么数组 nums 是单调递减的。

当给定的数组 nums 是单调数组时返回 true，否则返回 false。

```
示例 1：

输入：nums = [1,2,2,3]
输出：true
示例 2：

输入：nums = [6,5,4,4]
输出：true
示例 3：

输入：nums = [1,3,2]
输出：false
```

提示：

提示：

* `1 <= nums.length <= 10^5`
* `-10^5 <= nums[i] <= 10^5`


## 愚笨的思考

用 golang 实现第一个问题是我如何知道这是一个单调递增还是单调递减的数列.
使用了一个狗血的方案, 创建一个延后实现的函数, 通过这个函数来进行判断.
函数在第一出现不相同的时候, 进行实现.

方案是成功了, 运行耗时 116 ms, 我震惊了, 但这还超过了 93% 的用户, 感觉不知道说什么了.

我感觉我实现的很费劲, 这种实现好像不是很容易在 haskell 实现?
我需要定义两个函数, 但这两个函数最终使用是要动态决定, 不知道咋实现.

haskell 使用两次遍历明显比较简单, 也比较直接.

尝试只进行一次遍历, 就需要把遍历记录的状态进行合并.
单调判断条件是, 遍历过程中不能"出现过一次增并且出现过一次减"的情况.
遍历的时候同时做判断并记录下来, 最后返回结果就好了

