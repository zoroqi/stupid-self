---
aliases:
- 820. 单词的压缩编码
- 820. short encoding of words
tc:
- leetcode
- algorithm
leetcode:
  num: 820
  url: https://leetcode.cn/problems/short-encoding-of-words/
  tags:
  - 字典树
  - 哈希表
  - 数组
  - 字符串
date: "2023-01-13"
id: 20230113064055_2e218e8d44b34b1a
---

# 820. 单词的压缩编码

单词数组 `words` 的 **有效编码** 由任意助记字符串 `s` 和下标数组 `indices` 组成，且满足：

* `words.length == indices.length`
* 助记字符串 `s` 以 `'#'` 字符结尾
* 对于每个下标 `indices[i]` ，`s` 的一个从 `indices[i]` 开始、到下一个 `'#'` 字符结束（但不包括 `'#'`）的 **子字符串** 恰好与 `words[i]` 相等

给你一个单词数组 `words` ，返回成功对 `words` 进行编码的最小助记字符串 `s` 的长度 。

```
示例 1：

输入：words = ["time", "me", "bell"]
输出：10
解释：一组有效编码为 s = "time#bell#" 和 indices = [0, 2, 5] 。
words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"

示例 2：

输入：words = ["t"]
输出：2
解释：一组有效编码为 s = "t#" 和 indices = [0] 。
```

**提示：**

* `1 <= words.length <= 2000`
* `1 <= words[i].length <= 7`
* `words[i]` 仅由小写字母组成

## 愚笨的思考

看题看了很久, 可以用一个字典树来实现, 不过这个字典树是从单词最后一个字母计算的.

以示例一生成的字典树, 就是这个样子的两个分支.
```
0-e-m-i-t
0-b-e-l-l
```

我只需要实现一个字典树, 把我有内容灌入到里边就好了.
生成完字典树后, 求和所有叶子节点树高, 并加上叶子结点的数量就是返回结果.
这里有一个问题, ["time","im"] 这种可以压缩吗? 至少看描述是不可以.

## 看看答案的方案 PlanB

实际上可以对字符串进行排序, 只是排序的方式是反着进行排序的. 默认字符串排序是从第一位开始进行排序, 现在是从最后一位进行处理.
这个速度比字典树快多了.

这里需要进行计数需要判断, 当前是不是后一个元素的后缀表达式, 当不是后缀表达式的时候就把当前元素的长度追加到结果中.

在实现上, 直接把所有字符串翻转一遍之后在判断代码容易很多.
