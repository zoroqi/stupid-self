---
aliases:
- 804. 唯一摩尔斯密码词
- 804. unique morse code words
tc:
- leetcode
- algorithm
leetcode:
  num: 804
  url: https://leetcode.cn/problems/unique-morse-code-words/
  tags:
  - 数组
  - 哈希表
  - 字符串
id: 20221012213340_ecf36e7d34974c98
date: "2022-10-12"
---

# 806. 唯一摩尔斯密码词

国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，比如:

* `'a'` 对应 `".-"` ，
* `'b'` 对应 `"-..."` ，
* `'c'` 对应 `"-.-."` ，以此类推。

为了方便，所有 `26` 个英文字母的摩尔斯密码表如下：

`[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]`

给你一个字符串数组 `words` ，每个单词可以写成每个字母对应摩尔斯密码的组合。

* 例如，`"cab"` 可以写成 `"-.-..--..."` ，(即 `"-.-."` + `".-"` + `"-..."` 字符串的结合)。我们将这样一个连接过程称作 **单词翻译** 。

对 `words` 中所有单词进行单词翻译，返回不同 **单词翻译** 的数量。

```
示例 1：

输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释:
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
示例 2：

输入：words = ["a"]
输出：1
```

**提示：**

* `1 <= words.length <= 100`
* `1 <= words[i].length <= 12`
* `words[i]` 由小写英文字母组成

## 愚笨的思考

和 [806-number-of-lines-to-write-string](806-number-of-lines-to-write-string.md) 问题基本一致

### 计划A

调整映射关系, 最后使用 List.nub 去重就可以了.

### 没看懂的写法

简单写一个 golang 的程序提交测试, 发现第一名的代码很神奇, 不是很理解为啥.

```go
var vm = map[byte]int{'a': 1, 'b': 8, 'c': 10, 'd': 4,
    'e': 0, 'f': 2, 'g': 6, 'h': 0,
    'i': 0, 'j': 7, 'k': 5, 'l': 4,
    'm': 3, 'n': 2, 'o': 7, 'p': 6,
    'q': 13, 'r': 2, 's': 0, 't': 1,
    'u': 1, 'v': 1, 'w': 3, 'x': 9,
    'y': 11, 'z': 12}

var lm = map[byte]int{'a': 2, 'b': 4, 'c': 4, 'd': 3,
    'e': 1, 'f': 4, 'g': 3, 'h': 4,
    'i': 2, 'j': 4, 'k': 3, 'l': 4,
    'm': 2, 'n': 2, 'o': 3, 'p': 4,
    'q': 4, 'r': 3, 's': 3, 't': 1,
    'u': 3, 'v': 4, 'w': 3, 'x': 4,
    'y': 4, 'z': 4}

func uniqueMorseRepresentations(words []string) int {
    nm := make(map[int]bool)
    for _, w := range words {
        temp := 0
        for _, c := range w {
            temp <<= lm[byte(c)]
            temp |= vm[byte(c)]
        }
        nm[temp] = true
    }
    return len(nm)
}
```

`[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]`

比较可以看出, vm 对应的字母对应的的数字("`-`" 表示 1 "`.`" 表示 0); lm 对应 morse 的长度. 那代码含义就比较简单了, 将 morse 转换成数字拼接在一个 int 里, 这里强依赖与单个单词的长度不会超过 12 个字母, 和 int 是 64 位的, 不然就会出现丢失情况.
