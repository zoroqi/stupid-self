---
aliases:
- 894. 所有可能的真二叉树
- 894. all possible full binary trees
tc:
- leetcode
- algorithm
leetcode:
  num: 894
  url: https://leetcode.cn/problems/all-possible-full-binary-trees/
  tags:
  - 二叉树
  - 递归
  - 动态规划
  - 记忆优化搜索
date: "2023-05-18"
id: 20230518184727_41c475bd6e4e4c25
---

# 894. 所有可能的真二叉树

给你一个整数 n ，请你找出所有可能含 n 个节点的 真二叉树 ，并以列表形式返回。答案中每棵树的每个节点都必须符合 Node.val == 0 。

答案的每个元素都是一棵真二叉树的根节点。你可以按 任意顺序 返回最终的真二叉树列表。

真二叉树 是一类二叉树，树中每个节点恰好有 0 或 2 个子节点。


```
示例 1：
输入：n = 7
输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]

示例 2：

输入：n = 3
输出：[[0,0,0]]
```

**提示：**

* `1 <= n <= 20`

## 愚笨的思考

真二叉树的定义可以得出, 树的节点一定是奇数个.

所以有一个固定的返回结果, n 是偶数直接返回 0 个就好了

生成逻辑可以通过最简单的一个真二叉树进行对逐个叶子节点同时加入两个子节点, 就可以了, 然后生成重复的内容就可以了.

这里的涉及到了几个问题
1. 生成的二叉树如何进行编码来实现快速的排重
2. 如何减少 clone 二叉树的次数

### 暴力生成 PlanA

先不考虑这两个问题, 直接生成看看.
递归处理这个问题有点费劲啊

clone 之后我如何知道网那个位置写入两个子节点这是一个很难实现操作.
1. 递归中, 无法有效保留父节点的信息, 无法知道当前的位置.
2. 我知道了父节点或根节点信息, clone 之后也无法知道写新的节点写到那个位置.

知道怎么做了, 先写入, 再 clone, 再删除就好了.
狗血...

但是性能很慢, 导致最后一个测试用例超时了, 思路是对的, 但是需要在生成过程中进行排重并进行优化.

改成生成的时候进行去重, 然后勉强跑完, 用时 500ms

### 优化方案 PlanB

我可以只存储叶子节点的索引号, 最后通过索引号反向生成对应的二叉树, 这可能是一个可行的方案.

三个节点, 我只需要存储 `[1,2]` 5 个节点我需要存储 `[2,3,4]` `[1,5,6]`, 那这个就很好计算存储了, 我可以根据数组存储方式进行简单存储并进行扩展.
排重也会更简单一些.

排重就是排序后作为 key 就好了. 我以为 map 是可以用 `[]int` 做 key 的, 试了试好像不可以

我需要通过残缺的部分构造出会一个完整的 tree, 这个过程有点麻烦啊.
主要是我需要反向把路径填充进去, 有点麻烦啊.
来吧, map 打法.

直接 64ms 了, 可以理解成 8 倍的优化吗?

### 好像我想复杂了 PlanC

看题解有有一种简单的方式, 从子节点开始进行构建.
递归的从底层开始构建整棵树.

1. 生成左子树
2. 生成右子树
3. 拼接后返回

而且这个构建过程是从下向上进行构建的, 可以完全不用进行 copy 就可以实现新的树.

haskell 只实现 这个版本, 上边两个需要的三个递归嵌套有点太难了.

haskell 代码并不复杂, 可以说就一行 `dfs num = concat [[Node 0 l r | l <- (dfs x), r <- (dfs (num-1-x))] | x <- [1..num-1]]`.
但是性能真的差很多, 主要是没有缓存机制.

发现惰性求值性能是真的牛逼, 赋值是立刻完成, 但是真的需要进行计算时间就长了.

## 简单总结一下

我最开始的思路是从树顶开始一点点的向下构建, 主逻辑就是一个循环.
而从题解中得到的思路是从树底向上开始构建的, 这个逻辑就是递归构成的.

虽然不知道最开始我是如何进行构思的, 感觉自己掉入到一个坑里.
我是从1,3,5 如何逐渐添加节点, 所以整体的思路就是从上到下进行构建的.
完全不要考虑如何手动构建反而可能想到更优解, 采用命令式的思路会更好.

构建所有左子树, 构建右子树, 拼接起来就是一组新的树, 完全不用思考具体的构建过程.

没有优化思路的时候, 换一个思考方式可能会有新的想法.
