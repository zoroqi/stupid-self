---
aliases:
- 805. 数组的均值分割
- 805. split-array-with-same-average
tc:
- leetcode
- algorithm
leetcode:
  num: 805
  url: https://leetcode.cn/problems/split-array-with-same-average/
  tags:
  - 位运算
  - 数组
  - 数学
  - 动态规划
  - 状态压缩
date: "2022-11-14"
id: 20221114082236_b3af9c2d9bf444dd
---

# 805. 数组的均值分割

给定你一个整数数组 nums

我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空，并且 `average(A) == average(B)` 。

如果可以完成则返回true ，否则返回 false。

注意：对于数组 arr , average(arr) 是 arr 的所有元素的和除以 arr 长度。

```
示例 1:

输入: nums = [1,2,3,4,5,6,7,8]
输出: true
解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。

示例 2:

输入: nums = [3,1]
输出: false
```

提示:

* `1 <= nums.length <= 30`
* `0 <= nums[i] <= 10^4`

## 愚笨的思考

### 暴力方案 PlanA

暴力方案就比较简单了, 所有可能的分组方案, 注意检验就好了.
这个相对比较简单, 现实现了再说.
一直有一个疑问, 这里是不是所有测试用例都是可以整除的情况,
    要是出现一个不能整除的,
    因为需要进行 `==` 判断, 不是特殊的浮点数可能出问题.

先用简单的全排列分割实现, 作为基础验证.
性能很慢, 第二个需要优化成迭代器的方式进行计算, 不然会出现内存不够用的情况.

### 暴力方案 PlanB

A 是可以但最后还是卡死了, 所以调整成计算前 x 项的全组合
算法和 A 基本一样, 但依旧卡死.

这里有一个简单的处理, 可以只计算前 x 项就好了, 剩下的部分可以通过 `total - sum(x)` 进行计算.
不用计算剩下的内容是什么.

突然在想两个分组的平均值相同, 是否和整个数组的评价值相同? 证明看看.
```
数组 x 长度 lx 平均 ax; 数组 y 长度 ly 平均 ay.

设 ax == ay
完整数组和 sum = ax*lx + ax*ly
完整数组长度 length = lx+ly

avg = sum/length
=> (ax*lx + ax*ly)/(lx+ly)
=> (ax*(lx+ly))/(lx+ly)
=> ax
```

可以得到完整数组的平均值和部分数组是一致的

### 看看答案 PlanC

根据要求, 我们需要求得一个长度为 k 的子数组 A , 且平均值为 avg. 则 `sum(A) = k*avg` .
问题变成了, 我们从整个数组中取 k 个数字, 数字和是 `k*avg`.

我们设 `dp[i][x]` 表示当前已从数组 nums 取出 i 个元素构成的和为 x 的可能性
* 如果 `dp[i][x]=true`，表示当前已经遍历过的元素中可以取出 i 个元素构成的和为 x
* 如果 `dp[i][x]=false`，表示当前已经遍历过的元素中不存在取出 i 个元素的和等于 x

假设前 `j - 1` 个元素中存在长度为 i 的子集且子集的和为 x，则此时 `dp[i][x]=true`
我们当前遍历 `nums[j]` 时，则可以推出一定存在长度为 `i + 1` 的子集且满足子集的和为 `x + nums[j]`,
可以得到状态转移方程为：`dp[i+1][x+nums[j]]=dp[i][x]`.

判断公式可以进行一下推导
```
curr == k*avg
curr == k * (sum/l)
curr * l = k * sum
```

我是这么理解的, `dp[i]` 记录选择的子数组的长度,
    也就是表示 map 中的数据是几个元素加和而成的.
`map[int]` 记录了, 已经数字的和.

核心算法实现
1. 对数组进行遍历 n
2. 从 `l/2` 开始遍历直到 `1`
    1. 从 `dp[i-1]` 中获取已经计算的结果
    2. 逐一加上新的 n, 并判断是否符合要求
3. 没有数据之间 false

以 `[1, 2, 3, 4, 7, 8]` 举例,

以最外层循环进行状态记录, 不记录 `dp[0]`, 因为是固定的一个元素`0`

```
n=1
1 map[1]

n=2
1 map[1, 2]
2 map[3]25

n=3
1 map[1, 2, 3]
2 map[3, 4, 5] // 4,5 是 [1,2] + 3 得到的
3 map[6]

n=4
1 map[1, 2, 3, 4]
2 map[3, 4, 5, 6, 7] // 7 是 3+4 得到的
3 map[6, 7, 8, 9] // 7,8,9 是 [3,4,5] + 4 得到的

1 map[1, 2, 3, 4, 7]
2 map[3, 4, 5, 6, 7, 8, 9, 10, 11]
3 map[6, 7, 8, 9, 10, 11, 12, 13, 14]

1 map[1, 2, 3, 4, 7, 8]
2 map[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15]
3 map[6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
```

第 i 层对 `i-1` 层的所有可能性进行一次加和计算, 并存储下来

#### haskell 的 PlanC

剩下的挑战是 haskell 了, golang 用了三个循环, 那递归就至少三个了, 这个比较麻烦.
优先实现一个只是计算可能列表的函数, 类似 `[(length,sum)]` 对应累加求和的结果,
    之后在进行遍历判断, 或使用 any 来判断是否有符合结果的内容.

硬着头皮实现了一个, 但性能很烂, 也不知道咋优化.
之后需要研究看看如何优化了,
    可能放弃惰性求值可能有更好的效果.
或者是不要使用别的方式来实现可能会有更好的效果吧,
    但是我不知道如何实现这个逻辑.

我主动实现的递归只有一个, 剩下两个循环分别使用 foldr 和产生式来实现的.
    还好我想到了 fold 不然, 我又要实现一个递归了.
