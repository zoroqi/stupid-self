---
aliases:
- 890. 查找和替换模式
- 890. find and replace pattern
tc:
- leetcode
- algorithm
leetcode:
  num: 890
  url: https://leetcode.cn/problems/find-and-replace-pattern/
  tags:
  - 数组
  - 哈希表
  - 字符串
date: "2022-12-28"
id: 20221228062759_c564b376410c43c8
---

# 890. 查找和替换模式

你有一个单词列表 words 和一个模式  pattern，你想知道 words 中的哪些单词与模式匹配。

如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。

（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）

返回 words 中与给定模式匹配的单词列表。

你可以按任何顺序返回答案。

```
示例：

输入：words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
输出：["mee","aqq"]
解释：
"mee" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。
"ccc" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。
因为 a 和 b 映射到同一个字母。
```

提示：

1 <= words.length <= 50
1 <= pattern.length = words[i].length <= 20

## 愚笨的思考

对 pattern 每一个字母生成一个映射函数, 就像题中的 p(x) , 猜测合法的 #加密算法/恺撒密码 .

同步遍历
1. 是否有映射
    1. 没有创建一个
    2. 有就判断映射是否一致
        1. 不一致对下一个 word 进行判断
        2. 一致继续遍历


这是一个双射, 我需要两个 map 进行验证, 这个比较麻烦. 我能用一个搞定吗?
好像不能, 我需要用一个字段进行存储.

经过一次奇葩的优化, 把内存使用搞到了排名中的最小.
把之前有与判断的存在与否的 map 改成了数组, 反复清理这个数组实现更小的内存.

我使用的数组偏移量是 `rune-97`, 默认值 -1, 我感觉会编译不同过,
    主要是我以为 rune 类型是 uint32, 代表文字吗, 没有负数的情况.
但实际上是 int32, 好神奇啊.
找了下 utf-8 第一个位一定是 0, 那用 int32 就没有问题了.
