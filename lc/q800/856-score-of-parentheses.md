---
aliases:
- 856. 括号的分数
- 856. score of parentheses
tc:
- leetcode
- algorithm
leetcode:
  num: 856
  url: https://leetcode.cn/problems/score-of-parentheses/
  tags:
  - 栈
  - 字符串
date: "2022-10-27"
id: 20221027112939_2cfd322683844f27
---

# 856. 括号的分数

给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：

* `()` 得 1 分。
* `AB` 得 `A + B` 分，其中 A 和 B 是平衡括号字符串。
* `(A)` 得 `2 * A` 分，其中 A 是平衡括号字符串。

```
示例 1：
输入： "()"
输出： 1

示例 2：
输入： "(())"
输出： 2

示例 3：
输入： "()()"
输出： 2

示例 4：
输入： "(()(()))"
输出： 6
```

提示：

* S 是平衡括号字符串，且只含有 `( 和 )` 。
* 2 <= S.length <= 50

## 愚笨的思考

很有意思的一个题, 读完题就知道要用栈来实现, 但感觉可以有别的方式来实现.

只是为了刷题的话可以用正则实现,
    但很应该很费劲.
最长字符是 50, 也就是极限有 25 对括号,
    既然有确定的范围正则就可能实现的.

## 栈实现 PlanA

对括号是需要一个栈的,
    对转换成的数字需要第二个栈进行记录.
因为存在两种操作,
    我还需要在记录计算的符号,
    这个记录在什么地方呢?
这个可以根据连续的出栈数量进行记录,
    出栈就加一并记录其中.

写的时候发现, 我不需要验证括号,
    自然不用记录括号的栈了,
    只需要一个记录数字的栈就好了.

具体步骤
1. 遍历
2. 左括号入栈 0
3. 右括号出栈
    1. 0 变成 1 入栈
    2. 非 0 对栈中数据 `*2`
        1. 出栈第一个元素
        2. 非零再重新入栈
    3. 出栈到第一个 0 元素
    4. 出栈的所有元素进行求
        1. 有 0 元素需要入栈一个 0
        2. 将计算结果重新入栈
4. 返回栈顶元素

针对 `((()())(()))` 的代码中栈流程

```
0
0 0
0 0 0
0 0 1
0 0 1 0
0 0 2
0 4
0 4 0
0 4 0 0
0 4 0 1
0 6
12
```

狗血啊, leetcode 的 golang 不支持泛型,
  我用了 15min 实现一个简单的通用栈然后编译不通过, 好烦啊

这个用 haskell 实现感觉很费劲,
    我需要换个方式,
    主要是判断太多了,
    加上两个循环, 这是很麻烦的.
haskell 不能用这个算法实现

这个题的描述让我想到了 #邱奇数,
```
0 -> x -> ()
1 -> f x -> (())
2 -> f (f x) -> ((()))
2 -> f (f (f x)) -> (((())))
```

我的实现方式让我想到了一篇伟大的论文,
    #person/图灵在 <论可计算数及其在判定问题上的应用> 提出的那个理想的机器,
    并在其中实现了一些算法,
    那些算法就是一种类似的方式, 在只带上移动和转换
当然图灵的算法我只是看懂了第一个,
    因为第一个比较简单,
    还是在我理解范围内的.
当在提出"子程序"这个概念的时候彻底看不懂了,
    我就跳过了所有内容, 直接放弃了, 只是硬着头皮看完整个内容.

## 另一种设想 PlanB

这里我们可以把问题看成这样的一种翻译过程,
    一种类似语法分析的流程, 就像下面这样的过程.
```
A -> AA   {print A + A}
    | (A) {print (A) * 2}
    | ()  {print 1}
```

输入 `((()())(()))` 的翻译结果是 `2*(2*(1+1)+2*(1)))`

当然这个还不知如何实现, 作为之后的课题看看如何用 haskell 去实现.

用了一种方式来实现, 定义一个递归 data,
    分别表示 "()" "(A)" "AA" 三种情况.
用递归进行解析,
    解析方式是将括号分割成两个部分,
    分别对分割后的字符串进行递归解析来实现.

我是实现了 Read typeclass ,
    我没有做完整的解析校验,
    所以需要保证输入的正确性.

在实现解析后,
    计算的流程就很简单了,
    直接递归计算就好了.
根据对应声明类型进行作相应的解析计算就好了,
    也没有优先级概念(解析后已经变成了嵌套关系).

还是感觉多些点括号容易理解啊
