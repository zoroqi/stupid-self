---
aliases:
- 838. 推多米诺
- 838. push-dominoes
tc:
- leetcode
- algorithm
leetcode:
  num: 838
  url: https://leetcode.cn/problems/push-dominoes/
  tags:
  - 字符串
  - 双指针
  - 动态规划
id: 20221012215511_1036cbb5ef9245a6
date: "2022-10-12"
---

# 838. 推多米诺

`n` 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。

每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。

如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。

就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。

给你一个字符串 `dominoes` 表示这一行多米诺骨牌的初始状态，其中：

* `dominoes[i] = 'L'`，表示第 `i` 张多米诺骨牌被推向左侧，
* `dominoes[i] = 'R'`，表示第 `i` 张多米诺骨牌被推向右侧，
* `dominoes[i] = '.'`，表示没有推动第 `i` 张多米诺骨牌。

返回表示最终状态的字符串。

```
示例 1：

输入：dominoes = "RR.L"
输出："RR.L"
解释：第一张多米诺骨牌没有给第二张施加额外的力。
示例 2：

输入：dominoes = ".L.R...LR..L.."
输出："LL.RR.LLRRLL.."
```

提示:
* `n == dominoes.length`
* `1 <= n <= 105`
* `dominoes[i] 为 'L'、'R' 或 '.'`

## 愚笨的思考

"L" 想做左倒下, "R" 向右倒下, "." 等待被推到.

### 暴力方案 PlanA

进行一次遍历, 生成影响一步的状态, 直到状态不再变化位置.

golang 的一遍通过, 这是没有想到的, 也就是说这个思路是可以满足需求的, 总耗时 58ms 好长啊, 最快 8ms, 我还有 87% 的优化空间.

简单暴力好像没有能力用 haskell 实现, 主要是判断条件写起来太费劲了.

### 左右合并 PlanB

对 PlanA 可以简单看出一些规律, 需要改变的只有".", 而"."的改变只根据左右两边最近的元素状态的决定, 所以可以进行一下优化.

1. 找到连续的"."的 substr
2. 根据 substr 两端的状态处理中间状态
    1. 方法和 PlanA 类似
    2. 但不用反复循环了, 只需要从两端向中间逐个替换就可以了

需要注意边界条件, 判断写起来是真的很麻烦, 时间进入 16 ms, 优化 73% 的耗时.

haskell 依旧不知道咋写

#### 和 PlanA 的对比

PlanA 的完整遍历次数是和骨牌倾倒最长次数相关 "..........L" 就需要进行 10 次外层循环. 而 PlanB 最多进行两次完整循环就可以完成处理. 在空间上, 第一个需要两个数据进行交替替换, 而 PlanB 只需要一个数组就可以了.

