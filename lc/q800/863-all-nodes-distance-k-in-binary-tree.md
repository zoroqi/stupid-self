---
aliases:
- 863. 二叉树中所有距离为 K 的结点
- 863. all nodes distance k in binary tree
tc:
- leetcode
- algorithm
leetcode:
  num: 863
  url: https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/
  tags:
  - 广度优先遍历
  - 深度优先遍历
  - 二叉树
date: "2023-02-14"
id: 20230214192052_6e2aedbba05747b3
---

# 863. 二叉树中所有距离为 K 的结点

给定一个二叉树（具有根结点 `root`）， 一个目标结点 `target` ，和一个整数值 `k` 。

返回到目标结点 `target` 距离为 `k` 的所有结点的值的列表。 答案可以以 **任何顺序** 返回。

```
示例 1:
输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
输出：[7,4,1]
解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1
示例 2:

输入: root = [1], target = 1, k = 3
输出: []
```

**提示:**

* 节点数在 `[1, 500]` 范围内
* `0 <= Node.val <= 500`
* `Node.val` 中所有值 **不同**
* 目标结点 `target` 是树上的结点。
* `0 <= k <= 1000`


## 愚笨的思考

### 转换成数组表示 PlanA

第一反应是把数据转成数组表示, 因为原始数据没有办法反向回溯, 我需要进行一个递归的保留.

纸上简单试了下进行距离计算的时候更费劲, 还是算了.

### 深度遍历 PlanB

可以理解成"返回距离根节点制定距离的节点的集合".
我理解的这个距离是指最短距离, 不是走 k 步能到的距离

实现想法是进行两次递归遍历.
1. 第一次找到对 target 节点, 并生成到 target 到 root 的路径. 并需要记录一下两个信息
    * target 在路径节点的左子树还是右子树
    * 和 target 节点的距离
2. 第二次对这个路径中的节点的子节点进行树根遍历
    * 遍历不包含 target 部分的子树

一次成功, 感觉还不错.
