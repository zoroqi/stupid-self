---
aliases:
- 830. 较大分组的位置
- 830. positions of large groups
tc:
- leetcode
- algorithm
leetcode:
  num: 830
  url: https://leetcode.cn/problems/positions-of-large-groups
  tags:
  - 字符串
date: "2023-05-12"
id: 20230512173923_b77107e380894f24
---

# 830. 较大分组的位置

在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 s = "abbxxxxzyy"中，就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组。

分组可以用区间 `[start, end]` 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 "xxxx" 分组用区间表示为 `[3,6]` 。

我们称所有包含大于或等于三个连续字符的分组为 较大分组 。

找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。

```
示例1：

输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。

示例 2：

输入：s = "abc"
输出：[]
解释："a","b" 和 "c" 均不是符合要求的较大分组。

示例 3：

输入：s = "abcdddeeeeaabbbcd"
输出：[[3,5],[6,9],[12,14]]
解释：较大分组为 "ddd", "eeee" 和 "bbb"
示例 4：

输入：s = "aba"
输出：[]
```

提示：

- 1 <= s.length <= 1000
- s 仅含小写英文字母

## 愚笨的思考

1. 循环字符串
    1. 当合前一个字符不同的时候
        1. 判断统计长度是否大于 3
            1. 大于记录在结果中
            2. 不大于, 轻量长度记录
    2. 相同
        1. 判断是否第一次相同
            1. 记录开始位置
        2. 长度统计+1
2. 遍历完成, 判断计数是否 >3
    1. 补充最后一个记录


haskell 的逻辑就和英文标题一样, 通过 group + foldl 实现.
这里把所有结果折叠到一个列表中, 列表表示 `[(begin, length)]`, 过滤出长度大于 3 的, 之后通过 begin 计算出对应的开始和结束坐标就可以了.
虽然最后结果是反着的, 但是还可以.

是在不想用递归实现了, 就这样吧.
