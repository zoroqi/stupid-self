---
aliases:
- 815. 公交路线
- 815. bus routes
tc:
- leetcode
- algorithm
leetcode:
  num: 815
  url: https://leetcode.cn/problems/bus-routes/
  tags:
  - 广度优先遍历
  - 哈希表
date: "2022-11-30"
id: 20221130060053_5ee748791b464396
---

# 815. 公交路线

给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。

例如，路线 `routes[0] = [1, 5, 7]` 表示第 0 辆公交车会一直按序列 `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` 这样的车站路线行驶。
现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。

求出最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。


```
示例 1：

输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6
输出：2
解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。
示例 2：

输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
输出：-1
```


提示：

* `1 <= routes.length <= 500.`
* `1 <= routes[i].length <= 10^5`
* `routes[i] 中的所有值 互不相同`
* `sum(routes[i].length) <= 10^5`
* `0 <= routes[i][j] < 10^6``
* `0 <= source, target < 10^6`

## 愚笨的思考

看到后面的提示, 感觉范围好大啊, 都 `10^5` 了, 有点大啊. 问题问的是"**最少乘坐的公交车数量**", 而不是"**最短的坐车路径**".

### 暴力方案 PlanA

使用广度优先遍历就可以了, 在遍历的时候记录下当前深度应该就好了.
随便写的过程中发现需要用到好多 map 来进行记录, 感觉有点麻烦啊.

果然使用递归来保存状态是更简单来实现, 自己维护各种状态果然好费劲啊.

整体逻辑是
1. 写入一个队列, 队列元素由三个数据, 当前站点, 换乘次数
2. 对队列进行出队遍历直到队列为空
    1. 将可以达到此站的 line 中的站点写入队列
    2. 出现 target 站点, 直接返回换乘次数

这里有一个用来判断遍历过的 map , 保证一个站只验证一次.


靠着感觉实现了, 逻辑是对的, 遇到一个 `5 -> 5` 的返回结果是 0 , 我以为这个应该也是 1 呢.

逻辑上是对的, 但是面对一个巨大的数据上, 有太多无效的计算了, 所以需要一个方法进行过滤.
测试用例是有两天线路, 一条 50,000 站点, 总共 75,000 个站点. 直接崩了.
我的实现会对所有站点进行遍历, 所以至少是 75,000.

通过准假一个新的针对公交线的排重, 实现了尽量少的遍历. 可以执行完成了, 但时间已经很长, 用时 100ms 是最快的二倍.
调整队列长度果然可以减少内存的使用.
