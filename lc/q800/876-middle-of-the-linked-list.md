---
aliases:
- 876. 链表的中间结点
- 876. middle of the linked list
tc:
- leetcode
- algorithm
leetcode:
  num: 876
  url: https://leetcode.cn/problems/middle-of-the-linked-list/
  tags:
  - 链表
date: "2022-10-29"
id: 20221029103959_97759756bfe24f6a
---

# 876. 链表的中间结点

给定一个头结点为 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

```
示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.

示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
```

提示：

给定链表的结点数介于 1 和 100 之间。

## 愚笨的思考


返回后 $\lceil n/2 \rceil$ 个数据.
使用双指针就好了,
    一个 fast 指针每一次循环前进两步,
    一个 slow 指针每一次循环前进一步.
最后返回 slow 直到的方向就好了.


haskell 实现就不用链表了, 有点麻烦直接使用列表进行遍历替换吧.
haskell 的问题是我的实现会出现匹配不完全的情况,
    这个不知道如何处理.
缺少两个匹配, 但这个算法是不会出现的情况,
    缺少的是 slow 指针的会匹配到 "[]" 的情况.
这时候用 ListNode 就不会出现了.

这种无意义的匹配真的有意义吗? 至少在这个算法中是没有实际意义的, 因为算法实现可以保证不会出现 slow 指针会比 fast 早出现 `[]`.
但是不写会导致警告.
