---
aliases:
- 606. 根据二叉树创建字符串
- 606. construct string from binary tree
tc:
- leetcode
- algorithm
leetcode:
  num: 606
  url: https://leetcode.cn/problems/construct-string-from-binary-tree/
  tags:
  - 树
  - 二叉树
date: "2023-06-02"
id: "20230602141229_1886c5a6f5254ece"
---

# 606. 根据二叉树创建字符串

给你二叉树的根节点 root ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。

空节点使用一对空括号对 "()" 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

```
输入：root = [1,2,3,4]
输出："1(2(4))(3)"
解释：初步转化后得到 "1(2(4)())(3()())" ，但省略所有不必要的空括号对后，字符串应该是"1(2(4))(3)" 。

输入：root = [1,2,3,null,4]
输出："1(2()(4))(3)"
解释：和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。
```

**提示：**

- `树中节点的数目范围是 [1, 10^4]`
- `-1000 <= Node.val <= 1000`

## 愚笨的思考

没有完全看懂题, 先处理递归生成没有省略必要括号的结果看看.

完整的序列化规则是 `val(left)(right)`

我理解这个**不影响**的意思是, 左节点不能缺省, 右节点可以缺省, 叶子节点只保留 val 部分.

很好这次终于理解正确一次...

现在看 leetcode 的描述真的有点累.

haskell 的递归更简单.
