---
aliases:
- 662. 二叉树最大宽度
- 662. maximum width of binary tree
tc:
- leetcode
- algorithm
leetcode:
  num: 662
  url: https://leetcode.cn/problems/maximum-width-of-binary-tree/
  tags:
  - 二叉树
date: "2023-05-31"
id: "20230531145454_c27a248226d8434a"
---

# 662. 二叉树最大宽度

给你一棵二叉树的根节点 root ，返回树的最大宽度。

树的 最大宽度 是所有层中最大的 宽度 。

每一层的宽度被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。

题目数据保证答案将会在 32 位 带符号整数范围内。

```
示例 1：

输入：root = [1,3,2,5,3,null,9]
输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。

示例 2：

输入：root = [1,3,2,5,null,null,9,6,null,7]
输出：7
解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。

示例 3：

输入：root = [1,3,2,5]
输出：2
解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。
```

**提示：**

- 树中节点的数目范围是 `[1, 3000]`
- `-100 <= Node.val <= 100`

## 愚笨的思考

不是在计算包含最多的节点, 而是每层最左节点和最右节点之间的距离(水平距离?).

### 技术统计 PlanA

每一层的最大宽度是确定的, 每一层的节点可以进行如下的标号, 并且每一行的标号可以通过上层进行计算.
```
0
0   1
0 1 2 3
01234567
```

所以整体上应该是进行广度优先遍历计算出每一行的具体位置, 之后计算位置差值就可以了.

代码写完竟然超时了, 直接用题解的代码进行计算, 性能比我的好, 但也不至于超时啊.
做了一个基线测试比较, 耗时之减少了 13%.

另一个要命的是, leetcode 中的测试用例, 给出来的数据不是用"二叉树的数组表示法"进行展示的, 我测试用例都没有办法写.
手动构造这个树太费劲了.

又做了几轮基线测试我的又快了... 有点要命啊.

构造出来后, 整体也就减少了 10%, 按照 4ms 算也不至于超时啊.
无法理解为什么性能会超时, 无法理解这个超时的设定是个什么逻辑.
