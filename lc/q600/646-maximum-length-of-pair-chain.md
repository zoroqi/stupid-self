---
aliases:
- 646. 最长数对链
- 646. maximum length of pair chain
tc:
- leetcode
- algorithm
leetcode:
  num: 646
  url: https://leetcode.cn/problems/maximum-length-of-pair-chain/
  tags:
  - 贪心
  - 数组
  - 动态规划
date: "2023-05-30"
id: "20230530160825_7beffa7cfd9b45a9"
---

# 646. 最长数对链

给你一个由 n 个数对组成的数对数组 pairs ，其中 `pairs[i] = [lefti, righti]` 且 lefti < righti 。

现在，我们定义一种 跟随 关系，当且仅当 b < c 时，数对 `p2 = [c, d]` 才可以跟在 `p1 = [a, b]` 后面。我们用这种形式来构造数对链 。

找出并返回能够形成的 最长数对链的长度 。

你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

```
示例 1：

输入：pairs = [[1,2], [2,3], [3,4]]
输出：2
解释：最长的数对链是 [1,2] -> [3,4] 。
示例 2：

输入：pairs = [[1,2],[7,8],[4,5]]
输出：3
解释：最长的数对链是 [1,2] -> [4,5] -> [7,8] 。
```

**提示：**

- `n == pairs.length`
- `1 <= n <= 1000`
- `-1000 <= lefti < righti <= 1000`

## 愚笨的思考

### 逐一拼接 PlanA

根据 left 大小进行排序, 对数组进行遍历, 后一个元素需要和之前的元素尝试合并, 如果可以成功就把前一个元素进行调整.
循环这个过程知道最后.

时间复杂度 `O(n^2)`

果然有问题, 可能因为一个范围比较大的串导致整个结果无法进行合并.
比如 `[[7,9],[4,5],[7,9],[-7,-1],[0,10],[3,10],[3,6],[2,3]]` 就会导致 `[-7,-1] 和 [0,10]` 合并之后无法继续进行合并了.

思路应该是没有问题的, 每一个元素都进行存储, 尝试优化一下.

### 优化版 PlanB

存储一个结构, 这个结构保存所有拼接的可能, 在逐渐遍历过程中对计数进行增加, 最后返回最大的计数就可以了.

暂时的存储结构想法是 `map[right][left]int` 这样可以方便进行增加, 感觉是可以不存储 "left" 哪一级的, 这个之后再验证.

然后超时了, 结果应该是对的.

### 优化版 PlanC

好像不需要知道起点位置, 存储结构可以改成 `map[right]max` 就可以了.

成功, 完成所有测试用例.

### leetcode 官方题解 PlanD

代码是直接 copy 的, 比较代码实现上逻辑基本上是一致的, 但是性能上的差距是巨大的.

写一个简单的基线测试, 耗时减少了 92%.
可以理解成对 map 操作的耗时远远大于对数组操作的耗时.

之后多用数组进行记录比较好
